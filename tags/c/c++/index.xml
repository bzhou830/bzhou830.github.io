<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C/C&#43;&#43; on 十面埋伏的博客</title>
    <link>https://bzhou830.github.io/tags/C/C&#43;&#43;/</link>
    <description>Recent content in C/C&#43;&#43; on 十面埋伏的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 26 Feb 2019 09:16:34 +0800</lastBuildDate>
    
	<atom:link href="https://bzhou830.github.io/tags/C/C++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Windows驱动编程(1)：第一个驱动程序</title>
      <link>https://bzhou830.github.io/posts/20190226Windows%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B1/</link>
      <pubDate>Tue, 26 Feb 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/posts/20190226Windows%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B1/</guid>
      <description>&lt;p&gt;本篇主要介绍在VS2013环境下使用WDK8.1开发KMD驱动的一个简单的demo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发环境：VS2013, WDK8.1&lt;/li&gt;
&lt;li&gt;需要使用的工具：vmware player(安装windows xp作为实验环境), DriverMonitor(加载驱动的工具), DbgView(捕获内核的信息输出)&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;内存管理(3)：重载</title>
      <link>https://bzhou830.github.io/posts/20190112C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8603/</link>
      <pubDate>Sat, 12 Jan 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/posts/20190112C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8603/</guid>
      <description>&lt;p&gt;前面两篇中从整体上来看系统中四个层面上内存的分配和释放，然后详细的介绍了这四个层面中的操作符或函数的使用方法，以及他们背后的调用关系。这一篇中我们就从内存管理的实现的基本点“重载”开始，看看C++给我们提供了哪些可供使用的内存管理接口。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;内存管理(2)：内存操作相关函数</title>
      <link>https://bzhou830.github.io/posts/20190110C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8602/</link>
      <pubDate>Thu, 10 Jan 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/posts/20190110C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8602/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/8f5e4d215d97&#34;&gt;C++内存管理（1）——分配和释放的四个层面&lt;/a&gt; 上一篇中从整体上来看系统中四个层面上内存的分配和释放，这样我们就对内存分配有了一个整体的认识。这一节则详细的来写写这四个层面中的操作符或函数的使用方法，以及他们背后的调用关系。首先我们从我们使用最多的new和delete来说起。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;内存管理(1)：分配和释放的四个层面</title>
      <link>https://bzhou830.github.io/posts/20190106C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8601/</link>
      <pubDate>Sun, 06 Jan 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/posts/20190106C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8601/</guid>
      <description>&lt;p&gt;内存的使用是稍底层一些的程序，或者性能要求严格的程序都是非常有讲究的一块。从程序的分层设计的角度来看，一般有四个层面上内存的分配和释放可以共给我们开发人员使用。本篇就介绍这这个层面上内存分配相关的一些函数接口。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;面试题</title>
      <link>https://bzhou830.github.io/posts/20160406Cpp%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Wed, 06 Apr 2016 09:29:11 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/posts/20160406Cpp%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>一.static关键字的作用 1.修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。 2.修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，</description>
    </item>
    
  </channel>
</rss>