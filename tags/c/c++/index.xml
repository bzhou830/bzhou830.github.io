<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C/C&#43;&#43; on 菠萝蜜</title>
    <link>https://bzhou830.github.io/tags/C/C&#43;&#43;/</link>
    <description>Recent content in C/C&#43;&#43; on 菠萝蜜</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
<<<<<<< Updated upstream
    <lastBuildDate>Wed, 05 Feb 2020 19:16:34 +0800</lastBuildDate>
=======
    <lastBuildDate>Tue, 02 Aug 2022 19:16:34 +0800</lastBuildDate>
>>>>>>> Stashed changes
    
	<atom:link href="https://bzhou830.github.io/tags/C/C++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Windows驱动自签名</title>
      <link>https://bzhou830.github.io/post/20220802Windows%E9%A9%B1%E5%8A%A8%E8%87%AA%E7%AD%BE%E5%90%8D/</link>
      <pubDate>Tue, 02 Aug 2022 19:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20220802Windows%E9%A9%B1%E5%8A%A8%E8%87%AA%E7%AD%BE%E5%90%8D/</guid>
      <description>需要makecert.exe和signtool.exe这两个开发工具。这两个工具在WDK的安装包中就有的。例如我本地安装的WDK10.0.22000.0，那么在安装目录下即可看到这两个可执行文件。 先来介绍下这两个工具： makecert.exe 是用来生成证书文件的，也就是用它来生成一个后缀位.cer的文</description>
    </item>
    
    <item>
      <title>C&#43;&#43;中的字符串split</title>
      <link>https://bzhou830.github.io/post/20200205CppSplit/</link>
      <pubDate>Wed, 05 Feb 2020 19:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20200205CppSplit/</guid>
      <description>使用过Java, Python或者go这些语言然后切换到C++的同学很可能遇到一个问题就是：为什么在C++的string类里面为什么没有提供一个split函数呢？ 猜测可能有下面几个原因： split之后的结果存放在哪里呢？vector？但是string类中引入vector势必会造成s</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11中的多线程库</title>
      <link>https://bzhou830.github.io/post/20200202cpp11%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Sun, 02 Feb 2020 19:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20200202cpp11%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>1. 线程的创建 C++11中提供了thread类可以直接用来创建线程，创建步骤： 包含thread所在的头文件 #include &amp;lt;thread&amp;gt; 在需要的地方直接创建一个thread对象，构造函数中传入一个线程入口函数（或者是一个可调对象）。（普通函数，lambda表达式，重载了()的类都可以传入，普通类成员函数也可</description>
    </item>
    
    <item>
      <title>Windows内核编程05|调试</title>
      <link>https://bzhou830.github.io/post/20191231WindowsKernelPrograming05Debugging/</link>
      <pubDate>Tue, 31 Dec 2019 09:16:34 +0800</pubDate>
<<<<<<< Updated upstream
      
      <guid>https://bzhou830.github.io/post/20191231WindowsKernelPrograming05Debugging/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Windows内核编程04|内核工作流程</title>
      <link>https://bzhou830.github.io/post/20191230WindowsKernelPrograming04KernelFlow/</link>
      <pubDate>Mon, 30 Dec 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20191230WindowsKernelPrograming04KernelFlow/</guid>
      <description>1 简介 在应用层利用SetThreadPriority等API设置线程优先级是受到进程优先级限制的，所以本节就计划通过编写一个驱动程序和应用程序相结合突破这种限制。本节代码放在了Github上访问此链接 2 驱动程序初始化 先按照上一节的介绍来了解一下创建一个驱动程序的基本流程：入口函数</description>
    </item>
    
    <item>
      <title>Windows内核编程03|内核编程基础</title>
      <link>https://bzhou830.github.io/post/20191229WindowsKernelPrograming03KernelBasic/</link>
      <pubDate>Sun, 29 Dec 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20191229WindowsKernelPrograming03KernelBasic/</guid>
      <description>1. 内核编程一般准则 用户编程和内核编程之间的差别 1.1 未处理的异常 在用户模式下如果程序出现未处理的异常，整个程序会直接中止；在内核模式下出现未处理的异常，会造成系统奔溃，出现BSOD（蓝屏）。所以内核代码得非常小心，编译时绝对不能跳过任何细节和错误检查。 1.2 终止 当用户进程终止时不管是否正</description>
    </item>
    
    <item>
      <title>Windows内核编程02|环境搭建和部署测试</title>
      <link>https://bzhou830.github.io/post/20191228WindowsKernelPrograming02EnvSetup/</link>
      <pubDate>Sat, 28 Dec 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20191228WindowsKernelPrograming02EnvSetup/</guid>
      <description>1.安装VisualStudio2019 2.安装WindowsDriverKit 3.创建项目 4.添加代码 // driver.c #include &amp;lt;ntddk.h&amp;gt; // DriverEntry Routine DRIVER_INITIALIZE DriverEntry; // Unload Routine DRIVER_UNLOAD DriverUnload; // DriverEntry: 驱动程序的入口点 // DriverObject: 驱动程序对象 // RegistryPath: 注册表中的路径(驱动程序路径) NTSTATUS DriverEntry( _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath ) { // 编译器默认的警告等级为 /W4， // 并且开启 /WX 将警告视为错误</description>
    </item>
    
    <item>
      <title>Windows内核开发总结(二)</title>
      <link>https://bzhou830.github.io/post/20191224WindowsKernelProgramingSummer02/</link>
      <pubDate>Tue, 24 Dec 2019 09:16:34 +0800</pubDate>
      
=======
      
      <guid>https://bzhou830.github.io/post/20191231WindowsKernelPrograming05Debugging/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Windows内核编程04|内核工作流程</title>
      <link>https://bzhou830.github.io/post/20191230WindowsKernelPrograming04KernelFlow/</link>
      <pubDate>Mon, 30 Dec 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20191230WindowsKernelPrograming04KernelFlow/</guid>
      <description>1 简介 在应用层利用SetThreadPriority等API设置线程优先级是受到进程优先级限制的，所以本节就计划通过编写一个驱动程序和应用程序相结合突破这种限制。本节代码放在了Github上访问此链接 2 驱动程序初始化 先按照上一节的介绍来了解一下创建一个驱动程序的基本流程：入口函数</description>
    </item>
    
    <item>
      <title>Windows内核编程03|内核编程基础</title>
      <link>https://bzhou830.github.io/post/20191229WindowsKernelPrograming03KernelBasic/</link>
      <pubDate>Sun, 29 Dec 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20191229WindowsKernelPrograming03KernelBasic/</guid>
      <description>1. 内核编程一般准则 用户编程和内核编程之间的差别 1.1 未处理的异常 在用户模式下如果程序出现未处理的异常，整个程序会直接中止；在内核模式下出现未处理的异常，会造成系统奔溃，出现BSOD（蓝屏）。所以内核代码得非常小心，编译时绝对不能跳过任何细节和错误检查。 1.2 终止 当用户进程终止时不管是否正</description>
    </item>
    
    <item>
      <title>Windows内核编程02|环境搭建和部署测试</title>
      <link>https://bzhou830.github.io/post/20191228WindowsKernelPrograming02EnvSetup/</link>
      <pubDate>Sat, 28 Dec 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20191228WindowsKernelPrograming02EnvSetup/</guid>
      <description>1.安装VisualStudio2019 2.安装WindowsDriverKit 3.创建项目 4.添加代码 // driver.c #include &amp;lt;ntddk.h&amp;gt; // DriverEntry Routine DRIVER_INITIALIZE DriverEntry; // Unload Routine DRIVER_UNLOAD DriverUnload; // DriverEntry: 驱动程序的入口点 // DriverObject: 驱动程序对象 // RegistryPath: 注册表中的路径(驱动程序路径) NTSTATUS DriverEntry( _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath ) { // 编译器默认的警告等级为 /W4， // 并且开启 /WX 将警告视为错误</description>
    </item>
    
    <item>
      <title>Windows内核开发总结(二)</title>
      <link>https://bzhou830.github.io/post/20191224WindowsKernelProgramingSummer02/</link>
      <pubDate>Tue, 24 Dec 2019 09:16:34 +0800</pubDate>
      
>>>>>>> Stashed changes
      <guid>https://bzhou830.github.io/post/20191224WindowsKernelProgramingSummer02/</guid>
      <description>同步异步的两种用法 FILE_FLAG_OVERLAPPED异步打开参数 在CreateFile打开设备对象时 HANDLE CreateFile( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, //FILE_FLAG_OVERLAPPED HANDLE hTemplateFile ); 加入FILE_FLAG_OVERLAPPED参数就是以异步的方式打开驱动的设备对象 与驱动通讯时如下的调用界面及异步结构，需要设置一个OVE</description>
    </item>
    
    <item>
      <title>Windows内核开发总结(一)</title>
      <link>https://bzhou830.github.io/post/20191223WindowsKernelProgramingSummer01/</link>
      <pubDate>Mon, 23 Dec 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20191223WindowsKernelProgramingSummer01/</guid>
      <description>1. windows内核对象 每个对象都有对象头和对象体组成。所有类型的对象头结构都是相同的，而结构体部分却各不相同的。下面是内核对象的结构图： 进程句柄表 dt nt!_EPROCESS +0x000 Pcb : _KPROCESS +0x06c ProcessLock : _EX_PUSH_LOCK +0x070 CreateTime : _LARGE_INTEGER +0x078 ExitTime : _LARGE_INTEGER +0x080 RundownProtect : _EX_RUNDOWN_REF +0x084 UniqueProcessId : Ptr32 Void +0x088 ActiveProcessLinks : _LIST_ENTRY +0x090 QuotaUsage : [3] Uint4B +0x09c QuotaPeak : [3] Uint4B +0x0a8 CommitCharge : Uint4B +0x0ac PeakVirtualSize : Uint4B +0x0b0 VirtualSize : Uint4B +0x0b4 SessionProcessLinks : _LIST_ENTRY +0x0bc DebugPort : Ptr32 Void +0x0c0 ExceptionPort : Ptr32</description>
    </item>
    
    <item>
      <title>IRP和派遣函数</title>
      <link>https://bzhou830.github.io/post/20191220IRP%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 20 Dec 2019 13:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20191220IRP%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0/</guid>
      <description>什么是派遣函数? 派遣函数是 WIndows 驱动程序中的重要概念。驱动程序的主要功能是负责处理I/O请求，其中大部分I/O请求是在派遣函数中处理的。也就是说，派遣函数是用来处理驱动程序提交过来的 I/O 请求。 那什么是 I/O 请求呢？ 上层程序与驱动程序之间通信时，上层会发出I/O请求，即输入输出请求包（I/O</description>
    </item>
    
    <item>
      <title>C&#43;&#43;内存管理|05 各平台下std::allocator概览</title>
      <link>https://bzhou830.github.io/post/20180116C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8605/</link>
      <pubDate>Tue, 16 Jan 2018 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20180116C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8605/</guid>
      <description>1. VC6中的std::allocator VC6中的std::allocator源码实现如下图： 从图中可以发现，VC6中的std::allocator并没有进行memory pool这类的处理，直接在里面调用operator new()，进而调用::operator new，然后mall</description>
    </item>
    
    <item>
      <title>C&#43;&#43;内存管理|04 内存池</title>
      <link>https://bzhou830.github.io/post/20180114C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8604/</link>
      <pubDate>Sun, 14 Jan 2018 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20180114C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8604/</guid>
      <description>1. per-class allocator (ver 1.0) 前面几篇内存管理介绍了在C++中进行内存管理的接口，有了这些接口就可以开始使用这些工具管理内存。首先来看一个来自&amp;lt;&amp;lt;C++ Primer&amp;gt;&amp;gt; 3ed, p765的一个例子： #include &amp;lt;cstddef&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; class Screen { public: Screen(int x) :i(x) {}; int geti() { return i; }; void* operator new(size_t size) { Screen *p; if (!freeStore) { size_t chunk = screenChunk * size; freeStore = p = reinterpret_cast&amp;lt;Screen*&amp;gt;(new char[chunk]); for (; p != &amp;amp;freeStore[screenChunk - 1]; ++p) { p-&amp;gt;next = p +</description>
    </item>
    
    <item>
      <title>C&#43;&#43;内存管理|03 重载</title>
      <link>https://bzhou830.github.io/post/20180112C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8603/</link>
      <pubDate>Fri, 12 Jan 2018 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20180112C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8603/</guid>
      <description>前面两篇【C++内存管理】从整体上来看了系统中四个调用层面上的内存分配和释放，然后详细的介绍了这四个层面中的操作符/函数的使用以及背后的调用关系。在这一篇我们就从内存管理实现的基本点重载开始，看看C++给我们提供了哪些可供用户使用的内存管理接口。 应用程序的设计中，我们所说的内存管</description>
    </item>
    
    <item>
      <title>C&#43;&#43;内存管理|02 内存操作相关函数</title>
      <link>https://bzhou830.github.io/post/20180110C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8602/</link>
      <pubDate>Wed, 10 Jan 2018 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20180110C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8602/</guid>
      <description>上一篇中从整体上来看系统中四个层面上内存的分配和释放，这样我们就对内存分配有了一个整体的认识。这一节则详细的来写写这四个层面中的操作符或函数的使用方法，以及他们背后的调用关系。首先我们从我们使用最多的new和delete来说起。 1. new 和 delete new 操作符有时候也有地方称他为new opera</description>
    </item>
    
    <item>
      <title>C&#43;&#43;内存管理|01 分配和释放的四个层面</title>
      <link>https://bzhou830.github.io/post/20180106C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8601/</link>
      <pubDate>Sat, 06 Jan 2018 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20180106C&#43;&#43;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%8601/</guid>
      <description>内存的使用是稍底层一些的程序，或者性能要求严格的程序都是非常有讲究的一块。从程序的分层设计的角度来看，一般有四个层面上内存的分配和释放可以共给我们开发人员使用。本篇就介绍这这个层面上内存分配相关的一些函数接口。 1. 站在高处思考 从一个比较高的角度来看，内存管理说到底就是使用OS提供的</description>
    </item>
    
    <item>
      <title>C&#43;&#43;对象模型</title>
      <link>https://bzhou830.github.io/post/20170120Cpp%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 20 Jan 2017 19:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20170120Cpp%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</guid>
      <description>1. 类对象多占的空间 sizeof(空类) = ? 静态成员变量/函数，不占用类对象的空间 有虚函数时，类对象会多一个指针大小的空间（指向虚函数表vftbl） 对齐？ 2. 对象结构的演化和发展 3. this指针的调整 4. 分析obj文件 5. 拷贝构造函数 6. 程序转化语义 7. 程序的优化 class Value{ public: };</description>
    </item>
    
    <item>
      <title>C&#43;&#43;面试题</title>
      <link>https://bzhou830.github.io/post/20160406Cpp%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Wed, 06 Apr 2016 09:29:11 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20160406Cpp%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>一.static关键字的作用 1.修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。 2.修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，</description>
    </item>
    
    <item>
      <title>STL中的算法</title>
      <link>https://bzhou830.github.io/post/20160306STL%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 06 Mar 2016 09:29:11 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20160306STL%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%AE%97%E6%B3%95/</guid>
      <description>STL算法部分主要由头文件,,组成。要使用 STL中的算法函数必须包含头文件，对于数值算法须包含，中则定义了一些模板类，用来声明函数对象。 STL中算法大致分为四类： 1、非可变序列算法：指不直接修改其所操作的容器内容的算法。 2、可变序列算法：指可以修改它们所操作的容器内容的算法。 3、</description>
    </item>
    
  </channel>
</rss>