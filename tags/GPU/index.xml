<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GPU on 菠萝蜜</title>
    <link>https://bzhou830.github.io/tags/GPU/</link>
    <description>Recent content in GPU on 菠萝蜜</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 15 Feb 2021 19:16:34 +0800</lastBuildDate>
    
	<atom:link href="https://bzhou830.github.io/tags/GPU/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Shader在GPU中是如何执行的？</title>
      <link>https://bzhou830.github.io/post/20210215GPUShader/</link>
      <pubDate>Mon, 15 Feb 2021 19:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20210215GPUShader/</guid>
      <description>首先，我想说明一下，虽然文章的标题是 How GPU Works，但是我无意再去重复GPU工作的各个stage，流水线这些概念。本文会深入到更底层一点：GPU是如何执行shader的。在本文中，我除了GPU执行shader的方式之外，还有稍微涉及一些多核心，SIMD，超线程这些过去大家看上去貌</description>
    </item>
    
    <item>
      <title>渲染管线之旅|14 索引页</title>
      <link>https://bzhou830.github.io/post/20190830%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8514/</link>
      <pubDate>Fri, 30 Aug 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190830%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8514/</guid>
      <description>A trip through the Graphics Pipeline 2011 是发布在博客 http://fgiesen.wordpress.com 上的系列文章。主要涉及图形流水线在GPU中实现的方方面面。包括D3D/OpenGL app, UMD Driver, KMD Driver, GPU 硬件流水线设计等等。是非常好的学习图形学应用，GPU驱动等相关领域的资料。翻译的目的一方面是对学习的总结；另一方面是为了分享，因为国内在图形学， GPU相关的资</description>
    </item>
    
    <item>
      <title>渲染管线之旅|13 计算着色器</title>
      <link>https://bzhou830.github.io/post/20190825%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8513/</link>
      <pubDate>Sun, 25 Aug 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190825%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8513/</guid>
      <description>欢迎回到&amp;quot;渲染管线之旅&amp;quot;系列，本篇是“渲染管线之旅”的最后部分。这个系列已经够长了，后面可能写更多与GPU相关的文章。 之前我们一直遨游在图形渲染管线的所有常规部分，以及不同层级的具体细节。这篇我们来看DX11中引入的一项重要新功能：计算着色器（Computer</description>
    </item>
    
    <item>
      <title>渲染管线之旅|12 曲面细分</title>
      <link>https://bzhou830.github.io/post/20190820%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8512/</link>
      <pubDate>Tue, 20 Aug 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190820%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8512/</guid>
      <description>欢迎回来！这次，我们将研究D3D11 / Shader 5.x硬件世代所引入的“海报男孩”功能：细分。这个很有趣，既因为它是一个有趣的话题，又因为它标志着很长一段时间以来的第一次，这是一个重要的用户可见的组件已被添加到不可编程的图形管道中。 与从概念上讲很简单的“几何着色器”（它是一个可以看到整个</description>
    </item>
    
    <item>
      <title>渲染管线之旅|11 流输出</title>
      <link>https://bzhou830.github.io/post/20190815%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8511/</link>
      <pubDate>Thu, 15 Aug 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190815%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8511/</guid>
      <description>欢迎回来！ 这次，重点将放在流出（SO）上。 这是一种用于将“几何着色器”阶段的输出存储到内存中，而不是将其沿管道的其余部分发送的功能。 这可以用于例如 在D3D10级别的硬件上使用D3D10 API缓存外观化的顶点数据，或作为穷人的Compute Shader（请注意，使用D3D11，即使</description>
    </item>
    
    <item>
      <title>渲染管线之旅|10 几何着色器</title>
      <link>https://bzhou830.github.io/post/20190810%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8510/</link>
      <pubDate>Sat, 10 Aug 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190810%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8510/</guid>
      <description>欢迎回来。 上一次，我们深入到像素管线的底端。 这次，我们将切换回管道的中间，以查看D3D10：几何着色器可能是最明显的附加功能。 但是首先，我要进一步讲解如何分解本系列中的图形管道，以及与API呈现给你的视图有何不同。 Welcome back. Last time, we dove into bottom end of the pixel pipeline. This time, we’ll switch back to the middle of the pipeline to look at what is</description>
    </item>
    
    <item>
      <title>渲染管线之旅|09 像素处理之联合</title>
      <link>https://bzhou830.github.io/post/20190805%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8509/</link>
      <pubDate>Mon, 05 Aug 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190805%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8509/</guid>
      <description>这篇文章介绍了像素处理的后半部分，即“连接阶段”。 上一阶段的工作是将少量输入流转换成着色器单元的许多独立任务。 现在，我们需要将大量独立的计算折叠到一个（正确排序的）内存操作流中。 就像我在光栅化和Z早期的文章中已经做过的那样，我将首先简要介绍需要在一般级别上完成的工作，然后再介绍如</description>
    </item>
    
    <item>
      <title>渲染管线之旅|08 像素处理之&#34;fork&#34;</title>
      <link>https://bzhou830.github.io/post/20190801%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8508/</link>
      <pubDate>Thu, 01 Aug 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190801%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8508/</guid>
      <description>在这一部分中，我们来谈谈像素处理的前半部分:dispatch和实际的像素着色。事实上，这部分是大多数图形开发者在谈到PS stage时所关心的内容。有关alpha blend和Late-Z的内容放到下一篇文章中去探讨。后面我们会看到，硬件上PS stage的设计相是对比较复杂的。这也是</description>
    </item>
    
    <item>
      <title>渲染管线之旅|07 深度处理、模板处理</title>
      <link>https://bzhou830.github.io/post/20190730%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8507/</link>
      <pubDate>Tue, 30 Jul 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190730%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8507/</guid>
      <description>在这一篇中，我们来讨论Z-pipline的前端部分(简称它为early-Z), 以及它是在光栅化中怎么起作用的。和上一篇一样，本篇也不会按实际的管道顺序进行讨论；我将首先描述基础算法，然后再补充管线中的各个阶段（以相反的顺序可以更简单的解释这些内容）。 1.插值 Z通过三角形进行插值，</description>
    </item>
    
    <item>
      <title>渲染管线之旅|06 三角形的生成和建立</title>
      <link>https://bzhou830.github.io/post/20190725%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8506/</link>
      <pubDate>Thu, 25 Jul 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190725%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8506/</guid>
      <description>欢迎回来。这次我们去看看三角形的光栅化。但在光栅化三角形之前，我们需要执行三角形设置，并且在设置三角形之前，我还要解释一下我们做的准备是为了什么，最后我们来聊聊三角形硬件光栅化算法。 1.如何画一个三角形 首先，给很熟悉这部分并自己写过软纹理映射的人一点小提示：三角形光栅器一次要处理</description>
    </item>
    
    <item>
      <title>渲染管线之旅|05 图元处理、Clip/Cull, 投影和视图变换</title>
      <link>https://bzhou830.github.io/post/20190720%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8505/</link>
      <pubDate>Sat, 20 Jul 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190720%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8505/</guid>
      <description>上一篇中我们讨论了关于“纹理和采样”，这一篇我们回到3D管线的前端。在执行完顶点着色之后，就可以实际的渲染东西了，对吗？暂时还不行， 因为在我们实际开始光栅化图元之前，仍然还有很多事要做。所以在本篇里我们不会看到任何光栅化内容——还得等到下次再讲。 1. 图元装载 当我们离开顶点处理流水线</description>
    </item>
    
    <item>
      <title>渲染管线之旅|04 纹理和采样</title>
      <link>https://bzhou830.github.io/post/20190715%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8504/</link>
      <pubDate>Mon, 15 Jul 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190715%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8504/</guid>
      <description>上一篇讨论了顶点着色器,涵盖了GPU通用着色器处理单元的一些内容。它们都仅仅是向量处理单元, 但是当我们在访问Resource的时候,通常都不是这种向量的形式,所以GPU中还需要另一个专门用来在Pipeline中处理整数的单元：Texture Sampler. 这个单元内部相对比较复杂,复杂(也很有</description>
    </item>
    
    <item>
      <title>渲染管线之旅|03 图形管线概览及GPU中顶点处理</title>
      <link>https://bzhou830.github.io/post/20190710%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8503/</link>
      <pubDate>Wed, 10 Jul 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190710%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8503/</guid>
      <description>通过前面几篇的内容，我们知道，应用程序中的Draw API调用会经过D3D Runtime, 用户态驱动等等各个层级，最终将命令传到GPU的命令解释器，GPU就会根据命令的内容来进行图形的计算和处理。那么这一篇我们就来看看顶点的处理流程。 1. 开胃菜 在介绍GPU的顶点处理之前，我们先看看3D渲染管线。3</description>
    </item>
    
    <item>
      <title>渲染管线之旅|02 GPU存储架构和命令处理器</title>
      <link>https://bzhou830.github.io/post/20190705%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8502/</link>
      <pubDate>Fri, 05 Jul 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190705%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8502/</guid>
      <description>上一篇中主要介绍了3D渲染命令到达GPU之前经历过的各个阶段。用下图可以概括上一篇中所讲的内容，当然其中很多细节没有出现在图中。之前我们说KMD将命令送给了硬件，这个简单的“送”的过程实际上并不是那么简单的。我们知道显卡都是通过信号线连在主板上的，所以我们送命令都是需要走这些信号</description>
    </item>
    
    <item>
      <title>渲染管线之旅|01 软件调用栈</title>
      <link>https://bzhou830.github.io/post/20190703%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8501/</link>
      <pubDate>Wed, 03 Jul 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190703%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B9%8B%E6%97%8501/</guid>
      <description>简介 通常我们可以很容易的找到我们的个人电脑中显卡驱动软件调用栈的相关内容（attache到进程上，查看进程调用的dll。），但是这些调用关系是如何工作？它们又是为什么要这样做呢？这些问题就不那么容易找到答案了。我会尽量填补空白，而不会对特定的硬件进行具体的描述。我将主要讨论在Wi</description>
    </item>
    
    <item>
      <title>WDDM时序调用流程图</title>
      <link>https://bzhou830.github.io/post/20171217WDDM%E5%B7%A5%E4%BD%9C%E6%B5%81/</link>
      <pubDate>Sun, 17 Dec 2017 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20171217WDDM%E5%B7%A5%E4%BD%9C%E6%B5%81/</guid>
      <description>首先从WDDM驱动的框架图中来看看Driver是需要做什么事情的。下图中的带有灰色背景的就是GPU厂商提供的Driver需要实现的内容。 以一个简单的例子来看他们具体是怎么工作的： 1. Rendering Device 的创建 1、APPlication申请创建渲染设备时，display minport driver会接收到Dxgk</description>
    </item>
    
  </channel>
</rss>