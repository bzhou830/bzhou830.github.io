<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>图像处理 on 菠萝蜜</title>
    <link>https://bzhou830.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</link>
    <description>Recent content in 图像处理 on 菠萝蜜</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 08 Jun 2020 19:16:34 +0800</lastBuildDate>
    
	<atom:link href="https://bzhou830.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>谈谈OpenCV中的四边形</title>
      <link>https://bzhou830.github.io/post/20180608opencv_squares/</link>
      <pubDate>Mon, 08 Jun 2020 19:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20180608opencv_squares/</guid>
      <description>首先抛出一个问题，给定一系列二维平面上的的点，这些点是可以组成一个封闭的二维图形。因为这些点是矩形区域拍摄图像后识别得到的图形的边界点，所以我们要抽象出来这个矩形，也就是我们要反映出这个矩形。问题是在拍照的时候摄像头可能不是正对着图形的，那么矩形就必然在图像上反映为一个四边形, 如</description>
    </item>
    
    <item>
      <title>PyQt5&#43;OpenCV多线程显示摄像头数据</title>
      <link>https://bzhou830.github.io/post/20160515python_opencv_camera/</link>
      <pubDate>Fri, 15 May 2020 19:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20160515python_opencv_camera/</guid>
      <description>pyqt5是一套Python绑定Digia QT5应用的框架。它可用于Python 2和3。Qt库是最强大的GUI库之一。pyqt5很大的优势就是跨平台，而且使用起来非常的方便，编写的代码比较精简，又能实现比较复杂的界面。在很多视觉程序中都需要GUI, 搭配OpenCV, pyqt5可方</description>
    </item>
    
    <item>
      <title>集装箱OCR：使用EAST和Tesseract</title>
      <link>https://bzhou830.github.io/post/20190601%E9%9B%86%E8%A3%85%E7%AE%B1OCR%E4%BD%BF%E7%94%A8EAST%E5%92%8Ctesseract/</link>
      <pubDate>Sat, 01 Jun 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190601%E9%9B%86%E8%A3%85%E7%AE%B1OCR%E4%BD%BF%E7%94%A8EAST%E5%92%8Ctesseract/</guid>
      <description>本篇文章主要记录下使用EAST和Tesseract做自然场景中集装箱上字符OCR的一个简单的实现。 在看具体问题之前先来谈谈自然场景中文本检测这个领域。自然场景的文本检测和识别一直以来都是一个比较难的问题，在深度学习走红之前，都是绞尽脑汁的变着法子提取有用的特征，然后做定位检测。得</description>
    </item>
    
    <item>
      <title>Android平台使用JNI方式调用OpenCV配置</title>
      <link>https://bzhou830.github.io/post/20190103Android%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8JNI%E6%96%B9%E5%BC%8F%E8%B0%83%E7%94%A8OpenCV%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Thu, 03 Jan 2019 09:16:34 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20190103Android%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8JNI%E6%96%B9%E5%BC%8F%E8%B0%83%E7%94%A8OpenCV%E9%85%8D%E7%BD%AE/</guid>
      <description>本文主要介绍 OpenCV3.4.2 在 android studio2.3 中的配置，并使用 JNI 方式调用 OpenCV 中 C/C++ 层函数。 Android Studio在2.2版本更新之后加入了CMAKE方式配置NDK的方法，这大大简化了之前通过Android.mk和Application.mk两个本地配置文件进行NDK开发的方式。这种方法在后续更新的版本中不断增强，越来</description>
    </item>
    
    <item>
      <title>DICOM影像中的窗宽窗位</title>
      <link>https://bzhou830.github.io/post/20161117DICOM%E5%BD%B1%E5%83%8F%E4%B8%AD%E7%9A%84%E7%AA%97%E5%AE%BD%E7%AA%97%E4%BD%8D/</link>
      <pubDate>Thu, 17 Nov 2016 09:29:11 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20161117DICOM%E5%BD%B1%E5%83%8F%E4%B8%AD%E7%9A%84%E7%AA%97%E5%AE%BD%E7%AA%97%E4%BD%8D/</guid>
      <description>1.为什么有窗宽窗位? 医学图像领域的关键技术窗技术，是CT检查中用以观察不同密度的正常组织或病变的一种显示技术，包括窗宽(window width)和窗位(window level)。由于各种组织结构或病变具有不同的CT值，因此想要显示某一组织结构细节时，应该选择适合观察该组织或病变</description>
    </item>
    
    <item>
      <title>DICOM通信|PDU数据包（2）</title>
      <link>https://bzhou830.github.io/post/20161008DICOM%E9%80%9A%E4%BF%A1PDU%E6%95%B0%E6%8D%AE%E5%8C%852/</link>
      <pubDate>Sat, 08 Oct 2016 09:29:11 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20161008DICOM%E9%80%9A%E4%BF%A1PDU%E6%95%B0%E6%8D%AE%E5%8C%852/</guid>
      <description>DICOM通信-PDU数据包(1)中主要分析了DICOM通信协议的连接协商请求和连接协商应答。 在7个PDU数据包中还有5个数据包，从结构上来看，他们比协议的协商过程要简单明了一些。 这篇博客就来分析下剩下的5种数据包。 博客中使用的是WireShark抓包工具获取到的通信传输数据。 1</description>
    </item>
    
    <item>
      <title>DICOM通信|PDU数据包（1）</title>
      <link>https://bzhou830.github.io/post/20161007DICOM%E9%80%9A%E4%BF%A1PDU%E6%95%B0%E6%8D%AE%E5%8C%851/</link>
      <pubDate>Fri, 07 Oct 2016 09:29:11 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20161007DICOM%E9%80%9A%E4%BF%A1PDU%E6%95%B0%E6%8D%AE%E5%8C%851/</guid>
      <description>DICOM上层协议为DIMSE提供透明的网络数据传输服务，即以上层协议规定的协议数据单元传送接收DIMSE的命令流与数据流。上层协议中制定了上层服务以及协议数据单元(Protocol Data Unit，PDU)。 PDU是处在同一层的对等体用来交换的信息格式，DICOM根据上层服务定义了以</description>
    </item>
    
    <item>
      <title>DCMTK读取DICOM文件</title>
      <link>https://bzhou830.github.io/post/20160915DCMTK%E8%AF%BB%E5%8F%96DICOM%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 15 Sep 2016 08:29:11 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20160915DCMTK%E8%AF%BB%E5%8F%96DICOM%E6%96%87%E4%BB%B6/</guid>
      <description>//.h文件 #pragma once class dicomRead { public: dicomRead(void); ~dicomRead(void); private: const char* PatientName; const char* PatientSex; long PatientAge; long Width; long Height; long Depth; long WindowsLevel; long WindowsWidth; double space[2]; double spaceZ; double ImagePosition[3]; double ImageOrientation[6]; unsigned short* buffer; public: const char* GetPatientName(); const char* GetPatientSex(); long GetPatientAge(); long GetWidth(); long GetHeight(); long GetDepth(); long GetWindowsLevel(); long GetWindowsWidth(); double* GetSpace(); double GetSpaceZ(double orientation[6],double position1[3],double position2[3]); double* GetImagePosition(); double* GetImageOrientation(); unsigned short* GetBuffer(); void DicomRead(const char* path); void compressionDicom(const char* path,int repType); void decompressionDicom(const char* path); void readDICOMInfo(const char* path); }; #include &amp;quot;dicomRead.h&amp;quot; #include &amp;lt;map&amp;gt; #include &amp;lt;math.h&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;quot;dcmtk\config\osconfig.h&amp;quot; #include &amp;quot;dcmtk\dcmdata\dctk.h&amp;quot; #include &amp;quot;dcmtk\dcmdata\dcxfer.h&amp;quot; #include &amp;quot;dcmtk\dcmdata\dctag.h&amp;quot; #include &amp;quot;dcmtk\dcmdata\dctagkey.h&amp;quot; #include &amp;quot;dcmtk\dcmdata\dcpxitem.h&amp;quot; #include &amp;quot;dcmtk\oflog\config.h&amp;quot; #include &amp;quot;dcmtk\dcmimgle\dcmimage.h&amp;quot; #include &amp;quot;dcmtk\dcmjpeg\djdecode.h&amp;quot; #include &amp;quot;dcmtk\dcmjpeg\djdijg12.h&amp;quot; #include &amp;quot;dcmtk\dcmjpeg\djdijg8.h&amp;quot; #include &amp;quot;dcmtk\dcmjpeg\djdijg16.h&amp;quot; #include &amp;quot;dcmtk\dcmjpeg\djencode.h&amp;quot; #include &amp;quot;dcmtk\dcmjpeg\djrploss.h&amp;quot; #include &amp;quot;dcmtk\dcmjpeg\djrplol.h&amp;quot; #include &amp;quot;dcmtk\dcmdata\dcrleerg.h&amp;quot; #include &amp;quot;dcmtk\dcmdata\dcrledrg.h&amp;quot; using</description>
    </item>
    
    <item>
      <title>OpenCV最大熵分割</title>
      <link>https://bzhou830.github.io/post/20151130OpenCV%E6%9C%80%E5%A4%A7%E7%86%B5%E5%88%86%E5%89%B2/</link>
      <pubDate>Mon, 30 Nov 2015 12:55:00 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20151130OpenCV%E6%9C%80%E5%A4%A7%E7%86%B5%E5%88%86%E5%89%B2/</guid>
      <description>1. 最大熵是什么？ 这里所说的熵是指信息熵，信息熵是来自于信息论的一个词，它是对系统所含信息的一种度量。通俗的讲，系统的不确定性越大，那么系统的信息熵就越大。反之，一个系统如果确定性高（系统越有序），那么整个系统的信息熵就越小。其数学定义表述如下： $$ H = -\int_{\-\infty}^{+\infty}p(x)log[p(x)]dx $$ 上式中，$p(x)$ 表示灰</description>
    </item>
    
    <item>
      <title>OpenCV最大间方差分割</title>
      <link>https://bzhou830.github.io/post/20151129OpenCV%E6%9C%80%E5%A4%A7%E9%97%B4%E6%96%B9%E5%B7%AE%E5%88%86%E5%89%B2/</link>
      <pubDate>Sun, 29 Nov 2015 12:55:00 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20151129OpenCV%E6%9C%80%E5%A4%A7%E9%97%B4%E6%96%B9%E5%B7%AE%E5%88%86%E5%89%B2/</guid>
      <description>OpenCV中其实有对OTUS算法的实现，threhold()函数最后一个参数可以指定使用OTUS算法。 1、最大间方差(OTUS)算法的描述 和均值迭代算法相似，OTUS算法也是利用图像的直方图进行的。OTUS算法的思想是选取一个阈值$T， T \in [0,m-1]$,$m$为图像的灰度级</description>
    </item>
    
    <item>
      <title>OpenCV均值迭代分割</title>
      <link>https://bzhou830.github.io/post/20151128OpenCV%E5%9D%87%E5%80%BC%E8%BF%AD%E4%BB%A3%E5%88%86%E5%89%B2/</link>
      <pubDate>Sat, 28 Nov 2015 12:55:00 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20151128OpenCV%E5%9D%87%E5%80%BC%E8%BF%AD%E4%BB%A3%E5%88%86%E5%89%B2/</guid>
      <description>【题外话】:之前在博客中写过一篇“区域生长”的博客，区域生长在平时经常用到，也比较容易理解和代码实现，所以在很多情况下大家会选择这种方法。但是区域生长有一个最致命的点就是需要选取一个生长的种子点。 为了交流学习，同时也为了后面查阅方便，准备陆续将基于直方图的几种分割算法加以总结。 1</description>
    </item>
    
    <item>
      <title>OpenCV区域生长算法</title>
      <link>https://bzhou830.github.io/post/20151127OpenCV%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 27 Nov 2015 12:55:00 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20151127OpenCV%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF%E7%AE%97%E6%B3%95/</guid>
      <description>1.理论基础 区域生长算法的基本思想是将有相似性质的像素点合并到一起。对每一个区域要先指定一个种子点作为生长的起点，然后将种子点周围领域的像素点和种子点进行对比，将具有相似性质的点合并起来继续向外生长，直到没有满足条件的像素被包括进来为止。这样一个区域的生长就完成了。这个过程中有几</description>
    </item>
    
    <item>
      <title>图像插值运算总结</title>
      <link>https://bzhou830.github.io/post/20150324%E5%9B%BE%E5%83%8F%E6%8F%92%E5%80%BC%E8%BF%90%E7%AE%97%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 24 Mar 2015 09:29:11 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20150324%E5%9B%BE%E5%83%8F%E6%8F%92%E5%80%BC%E8%BF%90%E7%AE%97%E6%80%BB%E7%BB%93/</guid>
      <description>图像插值就是利用已知邻近像素点的灰度值（或RGB图像中的三色值）来产生未知像素点的灰度值，以便由原始图像再生出具有更高分辨率的图像。图像插值常常用在图像的放缩，旋转等变换中。常用的插值运算有三种：最邻近插值、双线性插值和立方卷积插值（cubic运算）。假设变换（放缩，旋转等等）前</description>
    </item>
    
    <item>
      <title>BMP图像编码格式</title>
      <link>https://bzhou830.github.io/post/20140906bmp%E7%BC%96%E7%A0%81/</link>
      <pubDate>Sat, 06 Sep 2014 09:29:11 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20140906bmp%E7%BC%96%E7%A0%81/</guid>
      <description>BMP文件由文件头、位图信息头、颜色信息和图形数据四部分组成。 1、文件头 BMP文件头数据结构含有BMP文件的类型、文件大小和位图起始位置等信息，一共包含14个字节。 例如：下图是个一个位图文件的二进制编码： 1-2字节：文件类型，必须是BM，十六进制中则是0x4d42； 3-6字节：位</description>
    </item>
    
  </channel>
</rss>