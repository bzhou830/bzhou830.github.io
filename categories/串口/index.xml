<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>串口 on 菠萝蜜</title>
    <link>https://bzhou830.github.io/categories/%E4%B8%B2%E5%8F%A3/</link>
    <description>Recent content in 串口 on 菠萝蜜</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 05 Aug 2015 09:29:11 +0800</lastBuildDate>
    
	<atom:link href="https://bzhou830.github.io/categories/%E4%B8%B2%E5%8F%A3/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C#中结构体定义并转换字节数组</title>
      <link>https://bzhou830.github.io/post/20150805Csharp%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Wed, 05 Aug 2015 09:29:11 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20150805Csharp%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89/</guid>
      <description>最近的项目在做socket通信报文解析的时候，用到了结构体与字节数组的转换；由于客户端采用C++开发，服务端采用C#开发，所以双方必须保证各自定义结构体成员类型和长度一致才能保证报文解析的正确性，这一点非常重要。 ​ 首先是结构体定义，一些基本的数据类型，C#与C++都是可以匹配的：</description>
    </item>
    
    <item>
      <title>C# 串口操作系列(5)</title>
      <link>https://bzhou830.github.io/post/20130618%E4%B8%B2%E5%8F%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%975/</link>
      <pubDate>Fri, 26 Apr 2013 09:29:11 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20130618%E4%B8%B2%E5%8F%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%975/</guid>
      <description>串口是很简单的，编写基于串口的程序也很容易。新手们除了要面对一堆的生僻概念，以及跨线程访问的细节，还有一个需要跨越的难题，就是协议解析，上一篇已经说明了: 一个二进制格式的协议一般包含： 协议头 + 数据段长度 + 数据 + 校验 一个Ascii格式的文本协议，一般包含： 数据头 + 正文 + 数据结束标识</description>
    </item>
    
    <item>
      <title>C# 串口操作系列(4)</title>
      <link>https://bzhou830.github.io/post/20130617%E4%B8%B2%E5%8F%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%974/</link>
      <pubDate>Wed, 24 Apr 2013 09:29:11 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20130617%E4%B8%B2%E5%8F%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%974/</guid>
      <description>上一篇已经介绍了协议的组成，一个协议，一般具有 ：协议头+长度+数据+校验 ， 文本格式可以直观的定义回车换行是协议的结尾，所以我们可以省略数据长度，增加协议尾。即： 协议头 + 数据 + 校验 + 数据尾 。 文本方式的数据比较容易分析。如果数据缓存，可以考虑用StringBuilder。或是不缓存也</description>
    </item>
    
    <item>
      <title>C# 串口操作系列(3)</title>
      <link>https://bzhou830.github.io/post/20130615%E4%B8%B2%E5%8F%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%973/</link>
      <pubDate>Tue, 23 Apr 2013 09:29:11 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20130615%E4%B8%B2%E5%8F%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%973/</guid>
      <description>我们的串口程序，除了通用的，进行串口监听收发的简单工具，大多都和下位机有关，这就需要关心我们的通讯协议如何缓存，分析，以及通知界面。 我们先说一下通讯协议。通讯协议就是通讯双方共同遵循的一套规则，定义协议的原则是尽可能的简单以提高传输率，尽可能的具有安全性保证数据传输完整正确。基于</description>
    </item>
    
    <item>
      <title>C# 串口操作系列(2)</title>
      <link>https://bzhou830.github.io/post/20130614%E4%B8%B2%E5%8F%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%972/</link>
      <pubDate>Sun, 21 Apr 2013 09:29:11 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20130614%E4%B8%B2%E5%8F%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%972/</guid>
      <description>第一篇文章我相信很多人不看都能做的出来，但是，用过微软SerialPort类的人，都遇到过这个尴尬，关闭串口的时候会让软件死锁。天哪，我可不是武断，算了。不要太绝对了。99.9%的人吧，都遇到过这个问题。我想只有一半的人真的解决了。另外一半的人就睁只眼闭只眼阿弥佗佛希望不要在客户</description>
    </item>
    
    <item>
      <title>C# 串口操作系列(1)</title>
      <link>https://bzhou830.github.io/post/20130612%E4%B8%B2%E5%8F%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%971/</link>
      <pubDate>Thu, 18 Apr 2013 09:29:11 +0800</pubDate>
      
      <guid>https://bzhou830.github.io/post/20130612%E4%B8%B2%E5%8F%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%971/</guid>
      <description>我假设读者已经了解c#的语法，本文是针对刚打算接触串口编程的朋友阅读的，作为串口编程的入门范例，也是我这个系列的基础。 一个基本的串口程序，既然是个程序了。我们就先从功能说起，包含： 串口选择 波特率选择 打开 关闭 接受数据显示 发送数据输入 发送数据 数据量提示以及归零 好吧，有了这些功能，我们</description>
    </item>
    
  </channel>
</rss>